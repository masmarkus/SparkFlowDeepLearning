
from sparkflow.pipeline_util import PysparkPipelineWrapper
from sparkflow.graph_utils import build_graph
from sparkflow.tensorflow_async import SparkAsyncDL
from pyspark.ml.feature import VectorAssembler, OneHotEncoder
from textwrap import dedent
from constants import SETTING
import numpy
import tensorflow as tf

# Graph definition
def small_model():
    x = tf.placeholder(tf.float32, shape=[None, 784], name='x')
    y = tf.placeholder(tf.float32, shape=[None, 10], name='y')
    layer1 = tf.layers.dense(x, 256, activation=tf.nn.relu)
    layer2 = tf.layers.dense(layer1, 256, activation=tf.nn.relu)
    out = tf.layers.dense(layer2, 10)
    z = tf.argmax(out, 1, name='out')
    loss = tf.losses.softmax_cross_entropy(y, out)
    return loss

def fixing_indentation(inp_str):
    """
    Fix indentation and clean unused line in inp_str.
    example:
    before fixing indentation
    ---------------------------------------------------------------
        #!/usr/bin/env python3
        # -*- coding: utf-8 -*-
        '''
        This code generated by running_executable_code.py made by: .
        Author: @author
        '''
        #==============================================================
        # Type code: Fit by Cross Validation
        #==============================================================
    ---------------------------------------------------------------
    after fixing indentation
    ---------------------------------------------------------------
    #!/usr/bin/env python3
    # -*- coding: utf-8 -*-
    '''
    This code generated by running_executable_code.py made by: .
    Author: @author
    '''
    #==============================================================
    # Type code: Fit by Cross Validation
    #==============================================================
    ---------------------------------------------------------------
    :param inp_str: (str) part of the executable code will be writen
                    in file .py
    :return: (str) string formatted
    """

    # clean unused line at begining and end
    clean_str = inp_str[inp_str.find("\n") + 1:inp_str.rfind("\n")]
    # fix indentation
    clean_str = dedent(clean_str)

    return clean_str

def write_import_modul(estimator, pipeline_type, message):
    """
    Write import all modul from estimator and/or evaluator.
    :param estimator: (dict) list of estimator from user pipeline
    :param pipeline_type: (int)
                            0: Fit General Pipeline
                            1: Fit Cross Validator
                            2: Fit Train Validation Split
                            3: Transform
    :param message: (list) message of current pipeline
    :return: (str) modul imported in string
    """

    # get modul dict
    modul_dict = SETTING["MODUL_DICT"]

    # Import all modul dependencies
    # Import evaluator in certain pipeline
    modul_imported = "\n"
    modul_imported += "from pyspark.ml import Pipeline\n"
    if pipeline_type != 0 and pipeline_type != 3:
        modul_imported += "from pyspark.ml.tuning import ParamGridBuilder\n"
        if pipeline_type == 1:
            # Cross Validator
            modul_imported += "from pyspark.ml.tuning import CrossValidator\n"
        elif pipeline_type == 2:
            # Train Validation Split
            modul_imported += \
                "from pyspark.ml.tuning import TrainValidationSplit\n"

        # both Cross Validator or Train Validation Split evaluator
        evaluator_modul = message["evaluator"]["name"]
        modul_imported += modul_dict[evaluator_modul] + "\n"

    # import estimator from each pipeline type
    import_statement = []
    for stg in range(len(estimator)):
        modul = list(estimator[stg].keys())[0]
        import_modul_str = modul_dict[modul]
        if import_modul_str not in import_statement:
            import_statement.append(import_modul_str)
            modul_imported += import_modul_str + "\n"

    modul_imported += "\n\n"

    return modul_imported

def write_stage_result_function_definition(pipeline_type):
    """
    Define a function stage_result and description,
    only define a function
    :param pipeline_type: (int)
                            0: Fit General Pipeline
                            1: Fit Cross Validator
                            2: Fit Train Validation Split
                            3: Transform
    :return: (str) stage_result function name and description in string
    """

    output = ""
    if pipeline_type == 0:
        output = "Pipeline model."
    elif pipeline_type == 1:
        output = "The best CV pipeline model."
    elif pipeline_type == 2:
        output = "The TVS best pipeline model."
    elif pipeline_type == 3:
        output = "Transformed dataset."

    stage_result = f"""
        def stage_result(data_train, message):
        \t\"\"\"
        \tInput: Dataset
        \tOutput: {output}
        \t\"\"\"
        """

    stage_result = fixing_indentation(stage_result)

    return stage_result



#if __name__ == '__main__':
#    write_stage_result_function_definition(0)
